//
// Created by loona on 10/28/21.
//

#include <stdio.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>
#include <stdlib.h>

#define TCP 6
#define PRINT_CODE_ERROR_AND_EXIT \
do {                              \
fprintf(stderr, "%d", errno) ; \
exit(errno);                      \
} while(0x00)                     \

void* listener (void* args);

int main(void) {
    int opt = 1;
    const struct sockaddr_in net_address = {AF_INET, htons(1987), INADDR_ANY};
    int socket_fd = 0;

    if ((socket_fd = socket(AF_INET, SOCK_STREAM, TCP)) == -1) {
        PRINT_CODE_ERROR_AND_EXIT;
    }

    if (setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT,&opt, sizeof(opt))) {
        PRINT_CODE_ERROR_AND_EXIT;
    }

    if (bind(socket_fd, (struct sockaddr *) &net_address, sizeof(struct sockaddr_in))) {
        PRINT_CODE_ERROR_AND_EXIT;
    }

    if (listen(socket_fd, 1)) {
        PRINT_CODE_ERROR_AND_EXIT;
    }

    int aceppt_fd = 0;
    aceppt_fd = accept(socket_fd, NULL, NULL);

    pthread_t thread_id = 0;
    if (errno = pthread_create(&thread_id, NULL, listener, &aceppt_fd)) {
            PRINT_CODE_ERROR_AND_EXIT;
    }

    if (errno = pthread_join(thread_id, NULL)) {
        PRINT_CODE_ERROR_AND_EXIT;
    }
    return 0;
}

void* listener (void* args) {
    int* p_inet_socket = args;
    char buf[100];
    for (char c, *ptr = buf; recv(*p_inet_socket, &c, sizeof(c), 0) == sizeof(c); *ptr = c, ptr++)
        if (c==0x0a) break;
    printf(buf); // i know this unsafe in thread
}
