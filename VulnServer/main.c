//
// Created by loona on 10/28/21.
//

#include <stdio.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>

#define TCP 6
#define PRINT_CODE_ERROR_AND_EXIT \
do {                              \
fprintf(stderr, "%d", errno) ; \
exit(errno);                      \
} while(0x00)                     \

void* listener (void* args);

int main(void) {
    setbuf(stdout, NULL);

    int opt = 1;
    const struct sockaddr_in net_address = {AF_INET, htons(1987), INADDR_ANY};
    int socket_fd = 0;

    if ((socket_fd = socket(AF_INET, SOCK_STREAM, TCP)) == -1) {
        PRINT_CODE_ERROR_AND_EXIT;
    }

    if (setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        PRINT_CODE_ERROR_AND_EXIT;
    }

    if (bind(socket_fd, (struct sockaddr *) &net_address, sizeof(struct sockaddr_in))) {
        PRINT_CODE_ERROR_AND_EXIT;
    }

    if (listen(socket_fd, 1)) {
        PRINT_CODE_ERROR_AND_EXIT;
    }

    int* aceppt_fd = NULL;
    do {
        if (!(aceppt_fd = malloc(sizeof(int)))) {
            errno = 4;
            PRINT_CODE_ERROR_AND_EXIT;
        }
        *aceppt_fd = accept(socket_fd, NULL, NULL);

        pthread_t thread_id = 0;
        if (errno = pthread_create(&thread_id, NULL, listener, aceppt_fd)) {
            PRINT_CODE_ERROR_AND_EXIT;
        }

        if (errno = pthread_join(thread_id, NULL)) {
            PRINT_CODE_ERROR_AND_EXIT;
        }
    } while (true);
    return 0;
}

void* listener (void* args) {
    int* socket = (int*) args;

    if (errno = pthread_detach(pthread_self())) {
        PRINT_CODE_ERROR_AND_EXIT;
    }

    char buf[100];
    for (char c, *ptr = buf; recv(*socket, &c, sizeof(c), 0) == sizeof(c); *ptr = c, ptr++)
        if (c == 0x0a) break;

    printf(buf); // i know this unsafe in thread
    close(*socket);
    free(socket);

    return NULL;
}
